<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Faktorisierungs-Demo</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <a href="index.html" class="nav-link">&larr; Zur√ºck zur Fiat-Shamir Demo</a>

    <h1 style="margin-top: 1rem;">Warum ist Faktorisierung schwer?</h1>
    <p>Die Sicherheit von Fiat-Shamir basiert darauf, dass es praktisch unm√∂glich ist, gro√üe Zahlen in ihre Primfaktoren zu zerlegen. Hier kannst du sehen, wie schnell die Rechenzeit mit der Bit-Gr√∂√üe explodiert.</p>

    <div class="card">
        <h2>Bit-Gr√∂√üe der Primzahlen w√§hlen</h2>

        <div class="slider-container">
            <label for="sliderP">Bit-Gr√∂√üe von <span class="vp">p</span>:</label>
            <input type="range" id="sliderP" class="bit-slider" min="3" max="11" value="5" step="1">
            <div class="bit-display" id="displayP">32 Bit</div>
        </div>

        <div class="slider-container">
            <label for="sliderQ">Bit-Gr√∂√üe von <span class="vp">q</span>:</label>
            <input type="range" id="sliderQ" class="bit-slider" min="3" max="11" value="5" step="1">
            <div class="bit-display" id="displayQ">32 Bit</div>
        </div>
    </div>

    <div class="card">
        <h2>Ergebnis</h2>

        <p><strong>Bit-Gr√∂√üe von <span class="vo">n</span> = <span class="vp">p</span> ¬∑ <span class="vp">q</span>:</strong></p>
        <div class="bit-display" id="displayN">64 Bit</div>

        <p><strong>Ungef√§hre Dezimalstellen von <span class="vo">n</span>:</strong></p>
        <div id="displayDigits" style="font-size: 1.1rem; font-weight: 600; color: var(--text-light);"></div>

        <p><strong>Beispiel <span class="vo">n</span>:</strong></p>
        <div class="n-display" id="displayNValue"></div>

        <!-- Sicherheits-Meter -->
        <p style="margin-top: 1rem;"><strong>Sicherheitsniveau:</strong></p>
        <div class="danger-meter">
            <div class="danger-fill" id="dangerFill" style="width: 0%; background: #27ae60;"></div>
        </div>
        <div id="dangerLabel" style="font-size: 0.85rem; color: var(--text-light);"></div>
    </div>

    <div class="result-card" id="resultCard">
        <h3>Gesch√§tzte Rechenzeit f√ºr Faktorisierung</h3>

        <!-- Quantum Toggle -->
        <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; flex-wrap: wrap;">
            <span id="algoLabel" style="font-size: 0.95rem; font-weight: 600;">Klassischer Computer</span>
            <label class="toggle-switch">
                <input type="checkbox" id="quantumToggle">
                <span class="toggle-slider"></span>
            </label>
            <span id="quantumBadge" class="quantum-badge" style="display:none;">Quantencomputer</span>
        </div>

        <p id="algoDescription" style="font-size: 0.85rem; color: var(--text-light);">
            Basierend auf dem <strong>General Number Field Sieve (GNFS)</strong> ‚Äî dem schnellsten bekannten klassischen Algorithmus.<br>
            Annahme: 10<sup>9</sup> Operationen/Sekunde.
        </p>

        <div class="time-display" id="timeDisplay">‚Äî</div>

        <div id="comparisons"></div>

        <!-- Quantum info box -->
        <div id="quantumInfo" class="quantum-info" style="display:none;">
            <strong>Shor's Algorithmus</strong> kann auf einem Quantencomputer jede Zahl in polynomieller Zeit faktorisieren: <span class="math">O(n¬≥)</span> Gatter-Operationen (n = Bit-Anzahl).<br><br>
            Das bedeutet: <strong>Egal wie gro√ü die Zahl</strong> ‚Äî ein ausreichend gro√üer Quantencomputer knackt sie in Sekunden.<br><br>
            <span style="font-size: 0.85rem; color: var(--text-light);">
                Stand heute (2026): Der gr√∂√üte mit Shor faktorisierte Wert ist noch sehr klein. Aber die Entwicklung schreitet voran ‚Äî deshalb wird bereits an <strong>Post-Quanten-Kryptografie</strong> gearbeitet.
            </span>
        </div>
    </div>

    <script>
    // Bit-Stufen: slider value -> actual bits
    const bitSteps = [8, 16, 32, 64, 128, 256, 512, 1024, 2048];

    const UNIVERSE_AGE_SECONDS = 4.35e17; // ~13.8 Mrd. Jahre in Sekunden
    const OPS_PER_SECOND = 1e9;

    let quantumMode = false;

    function sliderToBits(val) {
        return bitSteps[parseInt(val) - 3] || 32;
    }

    function update() {
        const pBits = sliderToBits(document.getElementById('sliderP').value);
        const qBits = sliderToBits(document.getElementById('sliderQ').value);
        const nBits = pBits + qBits;

        document.getElementById('displayP').textContent = pBits + ' Bit';
        document.getElementById('displayQ').textContent = qBits + ' Bit';
        document.getElementById('displayN').textContent = nBits + ' Bit';

        // Dezimalstellen
        const digits = Math.ceil(nBits * Math.log10(2));
        document.getElementById('displayDigits').textContent = '~' + digits + ' Stellen';

        // Beispiel-n generieren (approximiert)
        displayExampleN(nBits);

        if (quantumMode) {
            displayQuantumTime(nBits);
            displayDangerMeter(nBits);
        } else {
            // GNFS Komplexit√§t berechnen
            const lnN = nBits * Math.LN2;
            const lnLnN = Math.log(lnN);
            const constant = Math.pow(64 / 9, 1 / 3); // ‚âà 1.923
            const exponent = constant * Math.pow(lnN, 1 / 3) * Math.pow(lnLnN, 2 / 3);
            const logOps = exponent;
            const logOpsBase10 = logOps / Math.LN10;
            const logSecondsBase10 = logOpsBase10 - 9;

            displayTime(logSecondsBase10, nBits);
            displayDangerMeter(nBits);
        }
    }

    function displayQuantumTime(nBits) {
        const timeEl = document.getElementById('timeDisplay');
        const compEl = document.getElementById('comparisons');

        // Shor's Algorithmus: O(n¬≥) Gatter-Operationen, n = Bit-Anzahl
        // Annahme: 1 logisches Qubit-Gatter ~ 1 Mikrosekunde (optimistisch aber realistisch f√ºr Zukunft)
        // Ben√∂tigte logische Qubits: ~2n
        const gateOps = Math.pow(nBits, 3);
        const gateTimeSeconds = gateOps * 1e-6; // 1 Œºs pro Gatter

        let timeStr;
        if (gateTimeSeconds < 0.001) {
            timeStr = (gateTimeSeconds * 1e6).toFixed(0) + ' Mikrosekunden';
        } else if (gateTimeSeconds < 1) {
            timeStr = (gateTimeSeconds * 1000).toFixed(1) + ' Millisekunden';
        } else if (gateTimeSeconds < 60) {
            timeStr = gateTimeSeconds.toFixed(1) + ' Sekunden';
        } else if (gateTimeSeconds < 3600) {
            timeStr = (gateTimeSeconds / 60).toFixed(1) + ' Minuten';
        } else {
            timeStr = (gateTimeSeconds / 3600).toFixed(1) + ' Stunden';
        }

        timeEl.textContent = timeStr;
        timeEl.className = 'time-display quantum-time';

        const qubitsNeeded = 2 * nBits;

        let comparisons = [];

        comparisons.push({
            icon: '‚öõÔ∏è',
            text: `<strong>Shor's Algorithmus:</strong> ~${formatHugeNumber(gateOps)} Gatter-Operationen (${nBits}¬≥)`
        });

        comparisons.push({
            icon: 'üî¨',
            text: `Ben√∂tigte logische Qubits: <strong>~${qubitsNeeded.toLocaleString('de-DE')}</strong>`
        });

        // Vergleich mit aktuellem Stand
        if (qubitsNeeded <= 100) {
            comparisons.push({
                icon: '‚ö†Ô∏è',
                text: 'Das liegt bereits im Bereich heutiger Quantencomputer!'
            });
        } else if (qubitsNeeded <= 1000) {
            comparisons.push({
                icon: 'üîÆ',
                text: 'Noch nicht m√∂glich, aber voraussichtlich in wenigen Jahren erreichbar.'
            });
        } else if (qubitsNeeded <= 10000) {
            comparisons.push({
                icon: 'üöÄ',
                text: 'Erfordert Quantencomputer der n√§chsten Generation ‚Äî aktive Forschung l√§uft.'
            });
        } else {
            comparisons.push({
                icon: 'üèóÔ∏è',
                text: `Erfordert ${qubitsNeeded.toLocaleString('de-DE')} logische Qubits ‚Äî das sind Millionen physische Qubits mit Fehlerkorrektur.`
            });
        }

        compEl.innerHTML = comparisons.map(c =>
            `<div class="comparison-item">
                <span class="comparison-icon">${c.icon}</span>
                <span>${c.text}</span>
            </div>`
        ).join('');
    }

    function displayExampleN(nBits) {
        const el = document.getElementById('displayNValue');
        if (nBits <= 64) {
            // Tats√§chliche Berechnung m√∂glich
            if (nBits <= 32) {
                const low = Math.pow(2, nBits - 1);
                const high = Math.pow(2, nBits) - 1;
                const example = Math.floor(Math.random() * (high - low)) + low;
                el.textContent = example.toString();
            } else {
                const n = BigInt(2) ** BigInt(nBits - 1) + BigInt(Math.floor(Math.random() * 1e15));
                el.textContent = n.toString();
            }
        } else {
            // Gro√üe Zahl: zeige ungef√§hre Darstellung
            const digits = Math.ceil(nBits * Math.log10(2));
            let str = '';
            str += (Math.floor(Math.random() * 9) + 1).toString();
            for (let i = 1; i < digits; i++) {
                str += Math.floor(Math.random() * 10).toString();
            }
            el.textContent = str;
        }
    }

    function displayTime(logSecondsBase10, nBits) {
        const timeEl = document.getElementById('timeDisplay');
        const compEl = document.getElementById('comparisons');

        let timeStr = '';
        let comparisons = [];

        if (logSecondsBase10 < -6) {
            timeStr = '< 1 Mikrosekunde';
            timeEl.className = 'time-display safe';
        } else if (logSecondsBase10 < -3) {
            timeStr = '< 1 Millisekunde';
            timeEl.className = 'time-display safe';
        } else if (logSecondsBase10 < 0) {
            const seconds = Math.pow(10, logSecondsBase10);
            timeStr = seconds.toFixed(3) + ' Sekunden';
            timeEl.className = 'time-display safe';
        } else if (logSecondsBase10 < 2) {
            const seconds = Math.pow(10, logSecondsBase10);
            if (seconds < 60) {
                timeStr = seconds.toFixed(1) + ' Sekunden';
            } else {
                timeStr = (seconds / 60).toFixed(1) + ' Minuten';
            }
            timeEl.className = 'time-display';
        } else if (logSecondsBase10 < Math.log10(3.15e7)) { // < 1 Jahr
            const seconds = Math.pow(10, logSecondsBase10);
            const hours = seconds / 3600;
            const days = hours / 24;
            if (days < 1) {
                timeStr = hours.toFixed(1) + ' Stunden';
            } else if (days < 365) {
                timeStr = days.toFixed(0) + ' Tage';
            }
            timeEl.className = 'time-display';
        } else {
            // In Jahren
            const logYears = logSecondsBase10 - Math.log10(3.15e7);
            const years = Math.pow(10, logYears);

            if (years < 1000) {
                timeStr = years.toFixed(0) + ' Jahre';
            } else {
                timeStr = formatHugeNumber(years) + ' Jahre';
            }
            timeEl.className = 'time-display';

            // Vergleich mit Universumsalter
            const universeAge = 13.8e9; // Jahre
            const universeMultiple = years / universeAge;

            if (universeMultiple >= 1) {
                comparisons.push({
                    icon: 'üåå',
                    text: `<strong>${formatHugeNumber(universeMultiple)}√ó das Alter des Universums</strong> (13,8 Mrd. Jahre)`
                });
            }

            // Weitere Vergleiche
            if (years > 1e6) {
                comparisons.push({
                    icon: 'ü¶ï',
                    text: `Die Dinosaurier starben vor ~66 Mio. Jahren aus. Das ist <strong>${formatHugeNumber(years / 66e6)}√ó so lange</strong>.`
                });
            }
            if (years > 4.5e9) {
                comparisons.push({
                    icon: 'üåç',
                    text: `Die Erde existiert seit ~4,5 Mrd. Jahren. Das ist <strong>${formatHugeNumber(years / 4.5e9)}√ó so lange</strong>.`
                });
            }
            // Atom-Vergleich nur wenn logYears > 90 (also Jahre > 10^90, d.h. mehr als Atome*Universumsalter)
            if (logYears > 90) {
                const logAtomUniverses = logYears - 80 - Math.log10(universeAge);
                const atomUniverses = Math.pow(10, logAtomUniverses);
                comparisons.push({
                    icon: '‚öõÔ∏è',
                    text: `Selbst wenn jedes Atom im Universum (~10<sup>80</sup>) ein Computer w√§re, br√§uchte man noch <strong>${formatHugeNumber(atomUniverses)} Universen</strong>.`
                });
            }
        }

        timeEl.textContent = timeStr;

        if (nBits <= 16) {
            comparisons = [{
                icon: '‚ö°',
                text: 'Trivial l√∂sbar ‚Äî sogar von Hand m√∂glich!'
            }];
        } else if (nBits <= 64) {
            comparisons = [{
                icon: 'üíª',
                text: 'Ein normaler Computer knackt das in Sekundenbruchteilen.'
            }];
        } else if (nBits <= 256) {
            comparisons = [{
                icon: 'üñ•Ô∏è',
                text: 'Mit spezialisierter Hardware noch machbar, aber zunehmend aufw√§ndig.'
            }, ...comparisons];
        }

        compEl.innerHTML = comparisons.map(c =>
            `<div class="comparison-item">
                <span class="comparison-icon">${c.icon}</span>
                <span>${c.text}</span>
            </div>`
        ).join('');
    }

    function formatHugeNumber(n) {
        // Gibt eine menschenlesbare Darstellung ohne Exponentialnotation zur√ºck
        if (n < 10) return n.toFixed(1);
        if (n < 1000) return Math.round(n).toLocaleString('de-DE');
        if (n < 1e6) return (n / 1000).toFixed(1) + ' Tausend';
        if (n < 1e9) return (n / 1e6).toFixed(1) + ' Millionen';
        if (n < 1e12) return (n / 1e9).toFixed(1) + ' Milliarden';
        if (n < 1e15) return (n / 1e12).toFixed(1) + ' Billionen';
        if (n < 1e18) return (n / 1e15).toFixed(1) + ' Billiarden';
        if (n < 1e21) return (n / 1e18).toFixed(1) + ' Trillionen';
        if (n < 1e24) return (n / 1e21).toFixed(1) + ' Trilliarden';
        // F√ºr noch gr√∂√üere Zahlen: "X Stellen" Darstellung
        const digits = Math.floor(Math.log10(n)) + 1;
        return 'eine Zahl mit ' + digits + ' Stellen';
    }

    function displayDangerMeter(nBits) {
        const fill = document.getElementById('dangerFill');
        const label = document.getElementById('dangerLabel');

        let pct, color, text;

        if (quantumMode) {
            // Mit Quantencomputern ist alles unsicher
            pct = 3; color = '#e74c3c';
            text = 'Mit Quantencomputern ist RSA-basierte Kryptografie grunds√§tzlich unsicher ‚Äî egal welche Schl√ºssell√§nge.';
        } else if (nBits <= 64) {
            pct = 5; color = '#e74c3c'; text = 'Unsicher ‚Äî trivial zu knacken';
        } else if (nBits <= 256) {
            pct = 15; color = '#e67e22'; text = 'Schwach ‚Äî mit Aufwand knackbar';
        } else if (nBits <= 512) {
            pct = 30; color = '#f39c12'; text = 'Veraltet ‚Äî wurde bereits geknackt (RSA-155, 512 Bit, 1999)';
        } else if (nBits <= 1024) {
            pct = 55; color = '#f1c40f'; text = 'Grenzwertig ‚Äî gilt als unsicher seit ~2010';
        } else if (nBits <= 2048) {
            pct = 80; color = '#2ecc71'; text = 'Aktueller Standard ‚Äî sicher f√ºr die n√§chsten Jahre';
        } else {
            pct = 95; color = '#27ae60'; text = 'Sehr sicher ‚Äî empfohlen f√ºr langfristigen Schutz (RSA-4096)';
        }

        fill.style.width = pct + '%';
        fill.style.background = color;
        label.innerHTML = text;
    }

    // Toggle Quantum Mode
    document.getElementById('quantumToggle').addEventListener('change', function() {
        quantumMode = this.checked;

        const badge = document.getElementById('quantumBadge');
        const algoLabel = document.getElementById('algoLabel');
        const algoDesc = document.getElementById('algoDescription');
        const quantumInfo = document.getElementById('quantumInfo');

        if (quantumMode) {
            badge.style.display = 'inline-block';
            algoLabel.textContent = 'Quantencomputer';
            algoDesc.innerHTML =
                'Basierend auf <strong>Shor\'s Algorithmus</strong> ‚Äî faktorisiert in polynomieller Zeit: <span class="math">O(n¬≥)</span>.<br>' +
                'Annahme: 1 Œºs pro logischem Gatter (optimistisch, aber physikalisch plausibel).';
            quantumInfo.style.display = 'block';
        } else {
            badge.style.display = 'none';
            algoLabel.textContent = 'Klassischer Computer';
            algoDesc.innerHTML =
                'Basierend auf dem <strong>General Number Field Sieve (GNFS)</strong> ‚Äî dem schnellsten bekannten klassischen Algorithmus.<br>' +
                'Annahme: 10<sup>9</sup> Operationen/Sekunde.';
            quantumInfo.style.display = 'none';
        }

        update();
    });

    // Event listeners
    document.getElementById('sliderP').addEventListener('input', update);
    document.getElementById('sliderQ').addEventListener('input', update);

    // Initial
    update();
    </script>
</body>
</html>
